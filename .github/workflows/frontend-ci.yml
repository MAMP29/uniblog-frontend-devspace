name: Frontend CI

on:
  push:
    branches: [ "feature/**" ] # Para cambios en ramas de funcionalidad

  pull_request: # Este trigger es para el "primer paso" de CI (Build, Lint, Test)
    types: [opened, synchronize, reopened]
    branches: [ "develop", "main" ] # Cuando se abre/actualiza un PR hacia develop/main

  pull_request_target: # Este trigger es EXCLUSIVO para SonarCloud (y tiene acceso a secretos)
    types: [opened, synchronize, reopened]
    branches: [ "develop", "main" ]

jobs:
  # Job 1: Build, Lint & Test (Seguro para ejecutar código del fork)
  # Este job se dispara con 'pull_request' y 'push'.
  # Se ejecuta en el contexto del fork (para PRs) o de la rama (para push).
  # NO tiene acceso a SONAR_TOKEN, por lo que ejecutar código del fork aquí es seguro.
  build-lint-test:
    name: Build, Lint & Test Frontend
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push' # Se mantiene la lógica original
    permissions:
      contents: read # Solo lectura de contenido
      actions: read # Solo lectura de acciones
    strategy:
      matrix:
        node-version: [22.x]

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run Linter (ESLint)
      run: npm run lint

    - name: Build Project
      run: npm run build

    - name: Run Tests
      run: npm test -- --coverage

    # Subir el reporte de cobertura como un Artifact
    - name: Upload Coverage Report
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report-${{ github.sha }} # Nombre dinámico para evitar colisiones si hubiera varios PRs simultáneos
        path: coverage/lcov.info
      if: always() # Siempre intenta subir el artifact, incluso si los tests fallan.


  # Job 2: SonarCloud Scan (Seguro, se ejecuta en el repositorio base con secretos)
  # Este job SÓLO se dispara con 'pull_request_target'.
  # Accede a SONAR_TOKEN de forma segura porque el código ejecutado es de la rama base.
  sonar_scan:
    name: SonarCloud Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target'
    needs: build-lint-test # ¡Crucial! Asegura que build-lint-test ha terminado y subido el artifact.

    # Permisos específicos para SonarCloud, minimizando el acceso.
    permissions:
      contents: read        # Para checkout del repo (rama base)
      pull-requests: write  # Para enviar comentarios al PR
      security-events: write # Para enviar resultados de seguridad (ej. Code Quality y Code Smells)

    steps:
    - name: Checkout repository (Base Branch)
      uses: actions/checkout@v4
      with:
        # Aquí, el checkout se hace a la RAMA BASE (develop o main) del PR.
        # Esto es clave para la seguridad: no se ejecuta código arbitrario del fork.
        fetch-depth: 0

    # Descargar el reporte de cobertura
    - name: Download Coverage Report
      uses: actions/download-artifact@v4
      with:
        name: coverage-report-${{ needs.build-lint-test.outputs.sha }} # Descarga el artifact específico del job anterior
        path: coverage/

    - name: Set up Node.js for Sonar Scan
      uses: actions/setup-node@v4
      with:
        node-version: 22.x
        cache: 'npm'

    - name: Install dependencies for Sonar Scan (if needed for analysis)
      run: npm ci

    - name: SonarCloud Scan
      uses: SonarSource/sonarqube-scan-action@v4
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}